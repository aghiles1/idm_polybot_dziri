/*
 * generated by Xtext 2.14.0
 */
package fr.unice.polytech.dziri.polybot.serializer;

import com.google.inject.Inject;
import fr.unice.polytech.dziri.polybot.services.PolybotGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import polybot.Bot;
import polybot.Forward;
import polybot.GoTo;
import polybot.IfObjectDetected;
import polybot.IfObstacleDetected;
import polybot.Left;
import polybot.Point;
import polybot.PolybotPackage;
import polybot.Reverse;
import polybot.Right;
import polybot.TakeDropObject;
import polybot.While;

@SuppressWarnings("all")
public class PolybotSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PolybotGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PolybotPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PolybotPackage.BOT:
				sequence_Bot(context, (Bot) semanticObject); 
				return; 
			case PolybotPackage.FORWARD:
				sequence_Forward(context, (Forward) semanticObject); 
				return; 
			case PolybotPackage.GO_TO:
				sequence_GoTo(context, (GoTo) semanticObject); 
				return; 
			case PolybotPackage.IF_OBJECT_DETECTED:
				sequence_IfObjectDetected(context, (IfObjectDetected) semanticObject); 
				return; 
			case PolybotPackage.IF_OBSTACLE_DETECTED:
				sequence_IfObstacleDetected(context, (IfObstacleDetected) semanticObject); 
				return; 
			case PolybotPackage.LEFT:
				sequence_Left(context, (Left) semanticObject); 
				return; 
			case PolybotPackage.POINT:
				sequence_Point(context, (Point) semanticObject); 
				return; 
			case PolybotPackage.REVERSE:
				sequence_Reverse(context, (Reverse) semanticObject); 
				return; 
			case PolybotPackage.RIGHT:
				sequence_Right(context, (Right) semanticObject); 
				return; 
			case PolybotPackage.TAKE_DROP_OBJECT:
				sequence_TakeDropObject(context, (TakeDropObject) semanticObject); 
				return; 
			case PolybotPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Bot returns Bot
	 *
	 * Constraint:
	 *     (initialPosition=Point? (instructionList+=Instruction instructionList+=Instruction*)?)
	 */
	protected void sequence_Bot(ISerializationContext context, Bot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Forward
	 *     Move returns Forward
	 *     Forward returns Forward
	 *
	 * Constraint:
	 *     (speed=EInt duration=EInt)
	 */
	protected void sequence_Forward(ISerializationContext context, Forward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__SPEED));
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForwardAccess().getSpeedEIntParserRuleCall_3_0(), semanticObject.getSpeed());
		feeder.accept(grammarAccess.getForwardAccess().getDurationEIntParserRuleCall_5_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns GoTo
	 *     Move returns GoTo
	 *     GoTo returns GoTo
	 *
	 * Constraint:
	 *     (speed=EInt duration=EInt)
	 */
	protected void sequence_GoTo(ISerializationContext context, GoTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__SPEED));
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGoToAccess().getSpeedEIntParserRuleCall_3_0(), semanticObject.getSpeed());
		feeder.accept(grammarAccess.getGoToAccess().getDurationEIntParserRuleCall_5_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns IfObjectDetected
	 *     IfObjectDetected returns IfObjectDetected
	 *
	 * Constraint:
	 *     (listOfInstructions+=Instruction listOfInstructions+=Instruction*)
	 */
	protected void sequence_IfObjectDetected(ISerializationContext context, IfObjectDetected semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns IfObstacleDetected
	 *     IfObstacleDetected returns IfObstacleDetected
	 *
	 * Constraint:
	 *     (listOfInstructions+=Instruction listOfInstructions+=Instruction*)
	 */
	protected void sequence_IfObstacleDetected(ISerializationContext context, IfObstacleDetected semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Left
	 *     Move returns Left
	 *     Left returns Left
	 *
	 * Constraint:
	 *     (speed=EInt duration=EInt)
	 */
	protected void sequence_Left(ISerializationContext context, Left semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__SPEED));
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftAccess().getSpeedEIntParserRuleCall_3_0(), semanticObject.getSpeed());
		feeder.accept(grammarAccess.getLeftAccess().getDurationEIntParserRuleCall_5_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Point returns Point
	 *
	 * Constraint:
	 *     (x=EInt y=EInt)
	 */
	protected void sequence_Point(ISerializationContext context, Point semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.POINT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.POINT__X));
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.POINT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.POINT__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointAccess().getXEIntParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getPointAccess().getYEIntParserRuleCall_5_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Reverse
	 *     Move returns Reverse
	 *     Reverse returns Reverse
	 *
	 * Constraint:
	 *     (speed=EInt duration=EInt)
	 */
	protected void sequence_Reverse(ISerializationContext context, Reverse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__SPEED));
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReverseAccess().getSpeedEIntParserRuleCall_3_0(), semanticObject.getSpeed());
		feeder.accept(grammarAccess.getReverseAccess().getDurationEIntParserRuleCall_5_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Right
	 *     Move returns Right
	 *     Right returns Right
	 *
	 * Constraint:
	 *     (speed=EInt duration=EInt)
	 */
	protected void sequence_Right(ISerializationContext context, Right semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__SPEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__SPEED));
			if (transientValues.isValueTransient(semanticObject, PolybotPackage.Literals.MOVE__DURATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PolybotPackage.Literals.MOVE__DURATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightAccess().getSpeedEIntParserRuleCall_3_0(), semanticObject.getSpeed());
		feeder.accept(grammarAccess.getRightAccess().getDurationEIntParserRuleCall_5_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns TakeDropObject
	 *     TakeDropObject returns TakeDropObject
	 *
	 * Constraint:
	 *     {TakeDropObject}
	 */
	protected void sequence_TakeDropObject(ISerializationContext context, TakeDropObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns While
	 *     While returns While
	 *
	 * Constraint:
	 *     (nb=EInt listOfInstructions+=Instruction listOfInstructions+=Instruction*)
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
